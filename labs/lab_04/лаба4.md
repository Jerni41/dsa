---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.3
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```python
class ArrayStack:
    def __init__(self):  # Конструктор класса
        self._items = []  # Инициализация пустого списка для элементов
    
    def push(self, item):  # Добавление элемента в стек
        self._items.append(item)  # Добавляем элемент в конец списка
    
    def pop(self):  # Удаление и возврат верхнего элемента
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Stack is empty")  # Ошибка если стек пуст
        return self._items.pop()  # Удаляем и возвращаем последний элемент
    
    def peek(self):  # Просмотр верхнего элемента без удаления
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Stack is empty")  # Ошибка если стек пуст
        return self._items[-1]  # Возвращаем последний элемент
    
    def is_empty(self):  # Проверка стека на пустоту
        return len(self._items) == 0  # True если список пуст
    
    def __len__(self):  # Получение количества элементов
        return len(self._items)  # Возвращаем длину списка
    
    def __str__(self):  # Строковое представление
        return f"ArrayStack({self._items})"  # Красивый вывод

# Тестирование стека на массиве
print("=== Тестирование ArrayStack ===")
stack1 = ArrayStack()  # Создаем стек
stack1.push(1)  # Добавляем 1
stack1.push(2)  # Добавляем 2
stack1.push(3)  # Добавляем 3
stack1.push(9)
print(f"Стек после добавлений: {stack1}")  # Выводим стек
print(f"Верхний элемент: {stack1.peek()}")  # Смотрим верхний элемент
print(f"Удаленный элемент: {stack1.pop()}")  # Удаляем элемент
print(f"Стек после удаления: {stack1}")  # Выводим стек
print(f"Размер стека: {len(stack1)}")  # Проверяем размер
print(f"Пустой ли стек: {stack1.is_empty()}")  # Проверяем на пустоту
print()
```

```python
class ListNode:  # Класс узла связного списка
    def __init__(self, data):  # Конструктор узла
        self.data = data  # Сохраняем данные
        self.next = None  # Ссылка на следующий узел

class LinkedListStack:
    def __init__(self):  # Конструктор класса
        self._head = None  # Голова списка
        self._size = 0  # Счетчик элементов
    
    def push(self, item):  # Добавление элемента
        new_node = ListNode(item)  # Создаем новый узел
        new_node.next = self._head  # Новый узел указывает на текущую голову
        self._head = new_node  # Обновляем голову
        self._size += 1  # Увеличиваем счетчик
    
    def pop(self):  # Удаление и возврат элемента
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Stack is empty")  # Ошибка если пуст
        data = self._head.data  # Сохраняем данные
        self._head = self._head.next  # Перемещаем голову
        self._size -= 1  # Уменьшаем счетчик
        return data  # Возвращаем данные
    
    def peek(self):  # Просмотр верхнего элемента
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Stack is empty")  # Ошибка если пуст
        return self._head.data  # Возвращаем данные головы
    
    def is_empty(self):  # Проверка на пустоту
        return self._head is None  # True если голова None
    
    def __len__(self):  # Получение размера
        return self._size  # Возвращаем счетчик
    
    def __str__(self):  # Строковое представление
        items = []  # Список для элементов
        current = self._head  # Начинаем с головы
        while current:  # Пока есть узлы
            items.append(current.data)  # Добавляем данные
            current = current.next  # Переходим к следующему
        return f"LinkedListStack({items})"  # Возвращаем строку

# Тестирование стека на связном списке
print("=== Тестирование LinkedListStack ===")
stack2 = LinkedListStack()  # Создаем стек
stack2.push(10)  # Добавляем 10
stack2.push(20)  # Добавляем 20
stack2.push(30)  # Добавляем 30
print(f"Стек после добавлений: {stack2}")  # Выводим стек
print(f"Верхний элемент: {stack2.peek()}")  # Смотрим верхний элемент
print(f"Удаленный элемент: {stack2.pop()}")  # Удаляем элемент
print(f"Стек после удаления: {stack2}")  # Выводим стек
print(f"Размер стека: {len(stack2)}")  # Проверяем размер
print()
```

```python
class ArrayQueue:
    def __init__(self, capacity=10):  # Конструктор
        self._items = [None] * capacity  # Массив фиксированного размера
        self._front = 0  # Индекс начала
        self._rear = 0  # Индекс конца
        self._size = 0  # Количество элементов
        self._capacity = capacity  # Емкость массива
    
    def _resize(self):  # Увеличение емкости
        new_capacity = self._capacity * 2  # Удваиваем емкость
        new_items = [None] * new_capacity  # Новый массив
        for i in range(self._size):  # Копируем элементы
            new_items[i] = self._items[(self._front + i) % self._capacity]
        self._items = new_items  # Заменяем массив
        self._front = 0  # Сбрасываем начало
        self._rear = self._size  # Устанавливаем конец
        self._capacity = new_capacity  # Обновляем емкость
    
    def enqueue(self, item):  # Добавление в очередь
        if self._size == self._capacity:  # Если массив полон
            self._resize()  # Увеличиваем емкость
        self._items[self._rear] = item  # Добавляем элемент
        self._rear = (self._rear + 1) % self._capacity  # Двигаем конец
        self._size += 1  # Увеличиваем счетчик
    
    def dequeue(self):  # Удаление из очереди
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Queue is empty")  # Ошибка если пуста
        item = self._items[self._front]  # Берем первый элемент
        self._items[self._front] = None  # Очищаем ячейку
        self._front = (self._front + 1) % self._capacity  # Двигаем начало
        self._size -= 1  # Уменьшаем счетчик
        return item  # Возвращаем элемент
    
    def peek(self):  # Просмотр первого элемента
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Queue is empty")  # Ошибка если пуста
        return self._items[self._front]  # Возвращаем первый элемент
    
    def is_empty(self):  # Проверка на пустоту
        return self._size == 0  # True если нет элементов
    
    def __len__(self):  # Получение размера
        return self._size  # Возвращаем количество элементов
    
    def __str__(self):  # Строковое представление
        items = []  # Список для элементов
        for i in range(self._size):  # Обходим элементы
            items.append(self._items[(self._front + i) % self._capacity])
        return f"ArrayQueue({items})"  # Возвращаем строку

# Тестирование очереди на массиве
print("=== Тестирование ArrayQueue ===")
queue1 = ArrayQueue(5)  # Создаем очередь с емкостью 5
queue1.enqueue("A")  # Добавляем A
queue1.enqueue("B")  # Добавляем B
queue1.enqueue("C")  # Добавляем C
print(f"Очередь после добавлений: {queue1}")  # Выводим очередь
print(f"Первый элемент: {queue1.peek()}")  # Смотрим первый элемент
print(f"Удаленный элемент: {queue1.dequeue()}")  # Удаляем элемент
print(f"Очередь после удаления: {queue1}")  # Выводим очередь
print(f"Размер очереди: {len(queue1)}")  # Проверяем размер
print()
```

```python
class LinkedListQueue:
    def __init__(self):  # Конструктор
        self._head = None  # Голова очереди
        self._tail = None  # Хвост очереди
        self._size = 0  # Счетчик элементов
    
    def enqueue(self, item):  # Добавление в очередь
        new_node = ListNode(item)  # Создаем новый узел
        if self.is_empty():  # Если очередь пуста
            self._head = self._tail = new_node  # Голова и хвост - новый узел
        else:  # Если есть элементы
            self._tail.next = new_node  # Хвост указывает на новый узел
            self._tail = new_node  # Новый узел становится хвостом
        self._size += 1  # Увеличиваем счетчик
    
    def dequeue(self):  # Удаление из очереди
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Queue is empty")  # Ошибка если пуста
        data = self._head.data  # Сохраняем данные
        self._head = self._head.next  # Перемещаем голову
        if self._head is None:  # Если очередь опустела
            self._tail = None  # Хвост тоже None
        self._size -= 1  # Уменьшаем счетчик
        return data  # Возвращаем данные
    
    def peek(self):  # Просмотр первого элемента
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Queue is empty")  # Ошибка если пуста
        return self._head.data  # Возвращаем данные головы
    
    def is_empty(self):  # Проверка на пустоту
        return self._head is None  # True если голова None
    
    def __len__(self):  # Получение размера
        return self._size  # Возвращаем счетчик
    
    def __str__(self):  # Строковое представление
        items = []  # Список для элементов
        current = self._head  # Начинаем с головы
        while current:  # Пока есть узлы
            items.append(current.data)  # Добавляем данные
            current = current.next  # Переходим к следующему
        return f"LinkedListQueue({items})"  # Возвращаем строку

# Тестирование очереди на связном списке
print("=== Тестирование LinkedListQueue ===")
queue2 = LinkedListQueue()  # Создаем очередь
queue2.enqueue("X")  # Добавляем X
queue2.enqueue("Y")  # Добавляем Y
queue2.enqueue("Z")  # Добавляем Z
print(f"Очередь после добавлений: {queue2}")  # Выводим очередь
print(f"Первый элемент: {queue2.peek()}")  # Смотрим первый элемент
print(f"Удаленный элемент: {queue2.dequeue()}")  # Удаляем элемент
print(f"Очередь после удаления: {queue2}")  # Выводим очередь
print(f"Размер очереди: {len(queue2)}")  # Проверяем размер
print()
```

```python
class ArrayDeque:
    def __init__(self, capacity=10):  # Конструктор
        self._items = [None] * capacity  # Массив фиксированного размера
        self._front = 0  # Индекс начала
        self._size = 0  # Количество элементов
        self._capacity = capacity  # Емкость массива
    
    def _resize(self):  # Увеличение емкости
        new_capacity = self._capacity * 2  # Удваиваем емкость
        new_items = [None] * new_capacity  # Новый массив
        for i in range(self._size):  # Копируем элементы
            new_items[i] = self._items[(self._front + i) % self._capacity]
        self._items = new_items  # Заменяем массив
        self._front = 0  # Сбрасываем начало
        self._capacity = new_capacity  # Обновляем емкость
    
    def _get_back_index(self):  # Получение индекса последнего элемента
        return (self._front + self._size - 1) % self._capacity  # Вычисляем индекс
    
    def push_front(self, item):  # Добавление в начало
        if self._size == self._capacity:  # Если массив полон
            self._resize()  # Увеличиваем емкость
        self._front = (self._front - 1) % self._capacity  # Двигаем начало назад
        self._items[self._front] = item  # Добавляем элемент
        self._size += 1  # Увеличиваем счетчик
    
    def push_back(self, item):  # Добавление в конец
        if self._size == self._capacity:  # Если массив полон
            self._resize()  # Увеличиваем емкость
        back_index = (self._front + self._size) % self._capacity  # Вычисляем индекс
        self._items[back_index] = item  # Добавляем элемент
        self._size += 1  # Увеличиваем счетчик
    
    def pop_front(self):  # Удаление из начала
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        item = self._items[self._front]  # Берем первый элемент
        self._items[self._front] = None  # Очищаем ячейку
        self._front = (self._front + 1) % self._capacity  # Двигаем начало вперед
        self._size -= 1  # Уменьшаем счетчик
        return item  # Возвращаем элемент
    
    def pop_back(self):  # Удаление из конца
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        back_index = self._get_back_index()  # Получаем индекс последнего
        item = self._items[back_index]  # Берем последний элемент
        self._items[back_index] = None  # Очищаем ячейку
        self._size -= 1  # Уменьшаем счетчик
        return item  # Возвращаем элемент
    
    def peek_front(self):  # Просмотр начала
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        return self._items[self._front]  # Возвращаем первый элемент
    
    def peek_back(self):  # Просмотр конца
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        return self._items[self._get_back_index()]  # Возвращаем последний элемент
    
    def is_empty(self):  # Проверка на пустоту
        return self._size == 0  # True если нет элементов
    
    def __len__(self):  # Получение размера
        return self._size  # Возвращаем количество элементов
    
    def __str__(self):  # Строковое представление
        items = []  # Список для элементов
        for i in range(self._size):  # Обходим элементы
            items.append(self._items[(self._front + i) % self._capacity])
        return f"ArrayDeque({items})"  # Возвращаем строку

# Тестирование дека на массиве
print("=== Тестирование ArrayDeque ===")
deque1 = ArrayDeque(5)  # Создаем дек с емкостью 5
deque1.push_back(1)  # Добавляем 1 в конец
deque1.push_front(2)  # Добавляем 2 в начало
deque1.push_back(3)  # Добавляем 3 в конец
print(f"Дек после добавлений: {deque1}")  # Выводим дек
print(f"Первый элемент: {deque1.peek_front()}")  # Смотрим начало
print(f"Последний элемент: {deque1.peek_back()}")  # Смотрим конец
print(f"Удален из начала: {deque1.pop_front()}")  # Удаляем из начала
print(f"Удален из конца: {deque1.pop_back()}")  # Удаляем из конца
print(f"Дек после удалений: {deque1}")  # Выводим дек
print()
```

```python
class DoublyListNode:  # Класс узла двусвязного списка
    def __init__(self, data):  # Конструктор узла
        self.data = data  # Сохраняем данные
        self.prev = None  # Ссылка на предыдущий узел
        self.next = None  # Ссылка на следующий узел

class LinkedListDeque:
    def __init__(self):  # Конструктор
        self._head = None  # Голова дека
        self._tail = None  # Хвост дека
        self._size = 0  # Счетчик элементов
    
    def push_front(self, item):  # Добавление в начало
        new_node = DoublyListNode(item)  # Создаем новый узел
        if self.is_empty():  # Если дек пуст
            self._head = self._tail = new_node  # Голова и хвост - новый узел
        else:  # Если есть элементы
            new_node.next = self._head  # Новый узел указывает на голову
            self._head.prev = new_node  # Голова указывает на новый узел
            self._head = new_node  # Новый узел становится головой
        self._size += 1  # Увеличиваем счетчик
    
    def push_back(self, item):  # Добавление в конец
        new_node = DoublyListNode(item)  # Создаем новый узел
        if self.is_empty():  # Если дек пуст
            self._head = self._tail = new_node  # Голова и хвост - новый узел
        else:  # Если есть элементы
            new_node.prev = self._tail  # Новый узел указывает на хвост
            self._tail.next = new_node  # Хвост указывает на новый узел
            self._tail = new_node  # Новый узел становится хвостом
        self._size += 1  # Увеличиваем счетчик
    
    def pop_front(self):  # Удаление из начала
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        data = self._head.data  # Сохраняем данные
        if self._head == self._tail:  # Если один элемент
            self._head = self._tail = None  # Обнуляем голову и хвост
        else:  # Если больше одного элемента
            self._head = self._head.next  # Перемещаем голову
            self._head.prev = None  # Обнуляем ссылку на предыдущий
        self._size -= 1  # Уменьшаем счетчик
        return data  # Возвращаем данные
    
    def pop_back(self):  # Удаление из конца
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        data = self._tail.data  # Сохраняем данные
        if self._head == self._tail:  # Если один элемент
            self._head = self._tail = None  # Обнуляем голову и хвост
        else:  # Если больше одного элемента
            self._tail = self._tail.prev  # Перемещаем хвост
            self._tail.next = None  # Обнуляем ссылку на следующий
        self._size -= 1  # Уменьшаем счетчик
        return data  # Возвращаем данные
    
    def peek_front(self):  # Просмотр начала
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        return self._head.data  # Возвращаем данные головы
    
    def peek_back(self):  # Просмотр конца
        if self.is_empty():  # Проверка на пустоту
            raise IndexError("Deque is empty")  # Ошибка если пуст
        return self._tail.data  # Возвращаем данные хвоста
    
    def is_empty(self):  # Проверка на пустоту
        return self._head is None  # True если голова None
    
    def __len__(self):  # Получение размера
        return self._size  # Возвращаем счетчик
    
    def __str__(self):  # Строковое представление
        items = []  # Список для элементов
        current = self._head  # Начинаем с головы
        while current:  # Пока есть узлы
            items.append(current.data)  # Добавляем данные
            current = current.next  # Переходим к следующему
        return f"LinkedListDeque({items})"  # Возвращаем строку

# Тестирование дека на двусвязном списке
print("=== Тестирование LinkedListDeque ===")
deque2 = LinkedListDeque()  # Создаем дек
deque2.push_front("A")  # Добавляем A в начало
deque2.push_back("B")  # Добавляем B в конец
deque2.push_front("C")  # Добавляем C в начало
print(f"Дек после добавлений: {deque2}")  # Выводим дек
print(f"Первый элемент: {deque2.peek_front()}")  # Смотрим начало
print(f"Последний элемент: {deque2.peek_back()}")  # Смотрим конец
print(f"Удален из начала: {deque2.pop_front()}")  # Удаляем из начала
print(f"Удален из конца: {deque2.pop_back()}")  # Удаляем из конца
print(f"Дек после удалений: {deque2}")  # Выводим дек
print()
```

```python
def check_brackets(expression):  # Функция проверки скобок
    stack = ArrayStack()  # Создаем стек для скобок
    bracket_pairs = {')': '(', ']': '[', '}': '{'}  # Пары скобок
    
    for char in expression:  # Обходим каждый символ
        if char in '([{':  # Если открывающая скобка
            stack.push(char)  # Добавляем в стек
        elif char in ')]}':  # Если закрывающая скобка
            if stack.is_empty():  # Если стек пуст - ошибка
                return False  # Неправильное выражение
            if stack.pop() != bracket_pairs[char]:  # Если скобки не совпадают
                return False  # Неправильное выражение
    
    return stack.is_empty()  # True если все скобки закрыты

# Тестирование проверки скобок
print("=== Тестирование проверки скобок ===")
test_expressions = [  # Тестовые выражения
    ("()", True),  # Правильные
    ("()[]{}", True),  # Правильные
    ("([{}])", True),  # Правильные
    ("({[}])", False),  # Неправильные
    ("((()Ъ)", True),  # Правильные
    ("({)}", False),  # Неправильные
    ("((())", False),  # Неправильные
    ("", True)  # Пустая строка
]

for expr, expected in test_expressions:  # Для каждого теста
    result = check_brackets(expr)  # Проверяем выражение
    status = "✓" if result == expected else "✗"  # Статус проверки
    print(f"{status} '{expr}' -> {result} (ожидалось: {expected})")  # Вывод результата

print("\nВсе тесты пройдены!" if all(check_brackets(expr) == expected for expr, expected in test_expressions) 
      else "Некоторые тесты не пройдены!")
print()
```

```python
def evaluate_postfix(expression):  # Функция вычисления постфиксного выражения
    stack = ArrayStack()  # Создаем стек для чисел
    operators = {'+', '-', '*', '/'}  # Множество операторов
    
    for token in expression.split():  # Разбиваем на токены
        if token not in operators:  # Если токен - число
            stack.push(float(token))  # Преобразуем в число и добавляем в стек
        else:  # Если токен - оператор
            if len(stack) < 2:  # Проверяем, достаточно ли чисел
                raise ValueError("Invalid postfix expression")  # Ошибка если нет
            
            b = stack.pop()  # Берем второй операнд
            a = stack.pop()  # Берем первый операнд
            
            if token == '+':  # Сложение
                result = a + b  # Вычисляем сумму
            elif token == '-':  # Вычитание
                result = a - b  # Вычисляем разность
            elif token == '*':  # Умножение
                result = a * b  # Вычисляем произведение
            elif token == '/':  # Деление
                if b == 0:  # Проверка деления на ноль
                    raise ValueError("Division by zero")  # Ошибка если деление на ноль
                result = a / b  # Вычисляем частное
            else:  # Неизвестный оператор
                raise ValueError(f"Unknown operator: {token}")  # Ошибка
            
            stack.push(result)  # Добавляем результат в стек
    
    if len(stack) != 1:  # Проверяем, что остался только результат
        raise ValueError("Invalid postfix expression")  # Ошибка если нет
    
    return stack.pop()  # Возвращаем результат

# Тестирование вычисления постфиксных выражений
print("=== Тестирование вычисления постфиксных выражений ===")
test_expressions = [  # Тестовые выражения
    ("3 4 +", 7),  # 3 + 4 = 7
    ("5 2 * 3 +", 13),  # 5 * 2 + 3 = 13
    ("10 5 / 2 *", 4),  # 10 / 5 * 2 = 4
    ("4 5 6 * +", 34),  # 4 + 5 * 6 = 34
    ("3 4 + 2 * 7 /", 2)  # (3 + 4) * 2 / 7 = 2
]

for expr, expected in test_expressions:  # Для каждого теста
    result = evaluate_postfix(expr)  # Вычисляем выражение
    status = "✓" if abs(result - expected) < 0.001 else "✗"  # Статус проверки
    print(f"{status} '{expr}' = {result} (ожидалось: {expected})")  # Вывод результата

print("\nВсе вычисления выполнены правильно!" if all(abs(evaluate_postfix(expr) - expected) < 0.001 
      for expr, expected in test_expressions) else "Некоторые вычисления неверны!")
print()
```

```python
def infix_to_postfix(expression):  # Функция перевода в постфиксную запись
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}  # Приоритеты операторов
    associativity = {'+': 'L', '-': 'L', '*': 'L', '/': 'L', '^': 'R'}  # Ассоциативность
    
    output = []  # Выходной список
    stack = ArrayStack()  # Стек для операторов
    
    for token in expression.split():  # Разбиваем на токены
        if token.isdigit() or token.replace('.', '').isdigit():  # Если число
            output.append(token)  # Добавляем в выход
        elif token in precedence:  # Если оператор
            while (not stack.is_empty() and  # Пока стек не пуст
                   stack.peek() != '(' and  # И не открывающая скобка
                   (precedence[stack.peek()] > precedence[token] or  # И приоритет выше
                    (precedence[stack.peek()] == precedence[token] and  # Или приоритет равен
                     associativity[token] == 'L'))):  # И ассоциативность левая
                output.append(stack.pop())  # Перемещаем оператор в выход
            stack.push(token)  # Добавляем оператор в стек
        elif token == '(':  # Если открывающая скобка
            stack.push(token)  # Добавляем в стек
        elif token == ')':  # Если закрывающая скобка
            while not stack.is_empty() and stack.peek() != '(':  # Пока не найдем '('
                output.append(stack.pop())  # Перемещаем операторы в выход
            if stack.is_empty():  # Если стек пуст - ошибка
                raise ValueError("Mismatched parentheses")  # Непарные скобки
            stack.pop()  # Удаляем '(' из стека
    
    while not stack.is_empty():  # Перемещаем оставшиеся операторы
        if stack.peek() == '(':  # Проверка на незакрытые скобки
            raise ValueError("Mismatched parentheses")  # Непарные скобки
        output.append(stack.pop())  # Добавляем оператор в выход
    
    return ' '.join(output)  # Объединяем в строку

# Тестирование перевода в постфиксную запись
print("=== Тестирование перевода в постфиксную запись ===")
test_expressions = [  # Тестовые выражения
    ("3 + 4", "3 4 +"),  # Простое сложение
    ("3 + 4 * 5", "3 4 5 * +"),  # Приоритет операций
    ("( 3 + 4 ) * 5", "3 4 + 5 *"),  # Скобки
    ("3 * 4 + 5 * 6", "3 4 * 5 6 * +"),  # Множественные операции
    ("3 + 4 * 2 / ( 1 - 5 )", "3 4 2 * 1 5 - / +")  # Комплексное выражение
]

for infix, expected_postfix in test_expressions:  # Для каждого теста
    result = infix_to_postfix(infix)  # Переводим в постфиксную запись
    status = "✓" if result == expected_postfix else "✗"  # Статус проверки
    print(f"{status} '{infix}' -> '{result}' (ожидалось: '{expected_postfix}')")  # Вывод результата

print("\nВсе переводы выполнены правильно!" if all(infix_to_postfix(infix) == expected_postfix 
      for infix, expected_postfix in test_expressions) else "Некоторые переводы неверны!")
```

```python

```
