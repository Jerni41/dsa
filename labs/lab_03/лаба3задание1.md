from typing import Any, Self

class Node:
    def __init__(self, data:Any=None, next:'Node'=None):
        self.data = data
        self.next = next

    def __repr__(self):
         return f'{self.__class__.__name__}(data={self.data}, next={self.next})'

# ===== ВЕРСИЯ 1 =====
class SingleLinkedList_v1:
    def __init__(self) -> Self:
        '''Возвращает пустой список'''
        self._head = None

    def insert_first_node(self, value:Any) -> None:
        '''Добавить элемент в начало списка'''
        self._head = Node(value, self._head)

    def remove_first_node(self) -> Any:
        '''Удалить первый элемент списка'''
        temp = self._head.data
        self._head = self._head.next
        return temp

    def insert_last_node(self, value:Any) -> None:
        '''Добавить элемент в конец списка'''
        if self._head is None:
            self.insert_first_node(value)
        else:
            current_node = self._head
            while current_node.next is not None:
                current_node = current_node.next
            current_node.next = Node(value)

    def remove_last_node(self) -> Any:
        '''Удалить последний элемент списка'''
        if self._head.next is None:
            return self.remove_first_node()
        else:
            current_node = self._head
            while current_node.next.next is not None:
                current_node = current_node.next
            temp = current_node.next.data
            current_node.next = None
            return temp

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}({self._head})'

    def __str__(self):
        node = self._head
        l = []
        while node:
            l.append(str(node.data))
            node = node.next
        return 'LinkedList.head -> ' + ' -> '.join(l) + ' -> None'

# ===== ВЕРСИЯ 2 =====
class SingleLinkedList_v2(SingleLinkedList_v1):
    def get_size(self) -> int:
        '''Вернуть длину списка'''
        count = 0
        current_node = self._head
        while current_node is not None:
            count += 1
            current_node = current_node.next
        return count

    def find_node(self, value: Any) -> Any:
        '''Найти (первый) узел по его значению и вернуть значение'''
        current_node = self._head
        while current_node is not None:
            if current_node.data == value:
                return current_node.data
            current_node = current_node.next
        return None

    def replace_node(self, old_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и заменить его значение новым'''
        current_node = self._head
        while current_node is not None:
            if current_node.data == old_value:
                current_node.data = new_value
                return
            current_node = current_node.next

    def remove_node(self, value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить его'''
        if self._head is None:
            return None

        if self._head.data == value:
            return self.remove_first_node()

        current_node = self._head
        while current_node.next is not None:
            if current_node.next.data == value:
                temp = current_node.next.data
                current_node.next = current_node.next.next
                return temp
            current_node = current_node.next
            
        return None

# ===== ВЕРСИЯ 3 =====
class SingleLinkedList_v3(SingleLinkedList_v2):
    def __init__(self) -> None:
        '''Возвращает пустой список'''
        super().__init__()
        self._size = 0

    def insert_first_node(self, value: Any) -> None:
        '''Добавить элемент в начало списка'''
        super().insert_first_node(value)
        self._size += 1

    def remove_first_node(self) -> Any:
        '''Удалить первый элемент списка'''
        if self._head is None:
            return None
        result = super().remove_first_node()
        self._size -= 1
        return result

    def insert_last_node(self, value: Any) -> None:
        '''Добавить элемент в конец списка'''
        super().insert_last_node(value)
        self._size += 1

    def remove_last_node(self) -> Any:
        '''Удалить последний элемент списка'''
        if self._head is None:
            return None
        result = super().remove_last_node()
        self._size -= 1
        return result

    def remove_node(self, value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить его'''
        if self._head is None:
            return None

        if self._head.data == value:
            return self.remove_first_node()

        current_node = self._head
        while current_node.next is not None:
            if current_node.next.data == value:
                temp = current_node.next.data
                current_node.next = current_node.next.next
                self._size -= 1
                return temp
            current_node = current_node.next
            
        return None

    def get_size(self) -> int:
        '''Вернуть длину списка - O(1)'''
        return self._size

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}(size={self._size}, {self._head})'

    def __str__(self):
        return f'LinkedList(size={self._size}).head -> ' + super().__str__().split(' -> ', 1)[1]

# ===== ВЕРСИЯ 4 =====
class SingleLinkedList_v4(SingleLinkedList_v3):
    def find_previous_node(self, value: Any) -> Any:
        '''Найти (первый) узел по его значению и вернуть значение из предыдущего узла'''
        if self._head is None or self._head.next is None:
            return None
            
        if self._head.next.data == value:
            return self._head.data
            
        current_node = self._head
        while current_node.next is not None and current_node.next.next is not None:
            if current_node.next.next.data == value:
                return current_node.next.data
            current_node = current_node.next
            
        return None

    def find_next_node(self, value: Any) -> Any:
        '''Найти (первый) узел по его значению и вернуть значение из следующего узла'''
        current_node = self._head
        while current_node is not None:
            if current_node.data == value and current_node.next is not None:
                return current_node.next.data
            current_node = current_node.next
        return None

    def insert_before_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и добавить узел перед ним'''
        if self._head is None:
            return

        if self._head.data == target_value:
            self.insert_first_node(new_value)
            return

        current_node = self._head
        while current_node.next is not None:
            if current_node.next.data == target_value:
                new_node = Node(new_value, current_node.next)
                current_node.next = new_node
                self._size += 1
                return
            current_node = current_node.next

    def insert_after_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и добавить узел после него'''
        current_node = self._head
        while current_node is not None:
            if current_node.data == target_value:
                new_node = Node(new_value, current_node.next)
                current_node.next = new_node
                self._size += 1
                return
            current_node = current_node.next

    def replace_previous_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и заменить значение в предыдущем узле'''
        if self._head is None or self._head.next is None:
            return

        if self._head.next.data == target_value:
            self._head.data = new_value
            return
            
        current_node = self._head
        while current_node.next is not None and current_node.next.next is not None:
            if current_node.next.next.data == target_value:
                current_node.next.data = new_value
                return
            current_node = current_node.next

    def replace_next_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и заменить значение в следующем узле'''
        current_node = self._head
        while current_node is not None and current_node.next is not None:
            if current_node.data == target_value:
                current_node.next.data = new_value
                return
            current_node = current_node.next

    def remove_previous_node(self, target_value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить предыдущий узел'''
        if self._head is None or self._head.next is None:
            return None
            
        if self._head.next.data == target_value:
            return self.remove_first_node()
            
        current_node = self._head
        while current_node.next is not None and current_node.next.next is not None:
            if current_node.next.next.data == target_value:
                temp = current_node.next.data
                current_node.next = current_node.next.next
                self._size -= 1
                return temp
            current_node = current_node.next
            
        return None

    def remove_next_node(self, target_value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить следующий узел'''
        current_node = self._head
        while current_node is not None and current_node.next is not None:
            if current_node.data == target_value:
                temp = current_node.next.data
                current_node.next = current_node.next.next
                self._size -= 1
                return temp
            current_node = current_node.next
        return None

# ===== ВЕРСИЯ 5 =====
class SingleLinkedList_v5(SingleLinkedList_v4):
    def __init__(self) -> None:
        '''Возвращает пустой список'''
        super().__init__()
        self._tail = None

    def insert_first_node(self, value: Any) -> None:
        '''Добавить элемент в начало списка'''
        super().insert_first_node(value)
        if self._size == 1:
            self._tail = self._head

    def remove_first_node(self) -> Any:
        '''Удалить первый элемент списка'''
        if self._head is None:
            return None

        if self._head.next is None:
            self._tail = None
            
        result = super().remove_first_node()
        return result

    def insert_last_node(self, value: Any) -> None:
        '''Добавить элемент в конец списка - O(1)'''
        if self._head is None:
            self.insert_first_node(value)
        else:
            new_node = Node(value)
            self._tail.next = new_node
            self._tail = new_node
            self._size += 1

    def remove_last_node(self) -> Any:
        '''Удалить последний элемент списка'''
        if self._head is None:
            return None
            
        if self._head.next is None:
            return self.remove_first_node()
            
        current_node = self._head
        while current_node.next.next is not None:
            current_node = current_node.next
            
        temp = current_node.next.data
        current_node.next = None
        self._tail = current_node
        self._size -= 1
        return temp

    def insert_after_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и добавить узел после него'''
        current_node = self._head
        while current_node is not None:
            if current_node.data == target_value:
                new_node = Node(new_value, current_node.next)
                current_node.next = new_node
                self._size += 1
                if current_node == self._tail:
                    self._tail = new_node
                return
            current_node = current_node.next

    def remove_node(self, value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить его'''
        if self._head is None:
            return None
            
        if self._head.data == value:
            return self.remove_first_node()
            
        current_node = self._head
        while current_node.next is not None:
            if current_node.next.data == value:
                if current_node.next == self._tail:
                    self._tail = current_node
                    
                temp = current_node.next.data
                current_node.next = current_node.next.next
                self._size -= 1
                return temp
            current_node = current_node.next
            
        return None

    def remove_next_node(self, target_value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить следующий узел'''
        current_node = self._head
        while current_node is not None and current_node.next is not None:
            if current_node.data == target_value:
                if current_node.next == self._tail:
                    self._tail = current_node
                    
                temp = current_node.next.data
                current_node.next = current_node.next.next
                self._size -= 1
                return temp
            current_node = current_node.next
        return None

    def get_tail(self) -> Any:
        '''Получить значение последнего элемента'''
        return self._tail.data if self._tail else None

    def clear(self) -> None:
        '''Очистить весь список'''
        super().clear()
        self._tail = None

    def __repr__(self) -> str:
        tail_value = self._tail.data if self._tail else None
        return f'{self.__class__.__name__}(size={self._size}, head={self._head}, tail={tail_value})'

    def __str__(self):
        tail_info = f", tail={self._tail.data}" if self._tail else ""
        return f'LinkedList(size={self._size}{tail_info}).head -> ' + super().__str__().split(' -> ', 1)[1]
        
# ===== ВЕРСИЯ 6 =====
class SingleLinkedList_v6(SingleLinkedList_v5):
    def insert_before_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и добавить узел перед ним через замену'''
        current_node = self._head
        while current_node is not None:
            if current_node.data == target_value:
                old_value = current_node.data
                current_node.data = new_value
                new_node = Node(old_value, current_node.next)
                current_node.next = new_node
                self._size += 1
                if current_node == self._tail:
                    self._tail = new_node
                return
            current_node = current_node.next

    def replace_previous_node(self, target_value: Any, new_value: Any) -> None:
        '''Найти (первый) узел по его значению и заменить значение в предыдущем узле'''
        prev_value = self.find_previous_node(target_value)
        if prev_value is not None:
            current_node = self._head
            while current_node is not None:
                if current_node.data == prev_value:
                    current_node.data = new_value
                    return
                current_node = current_node.next

    def remove_previous_node(self, target_value: Any) -> Any:
        '''Найти (первый) узел по его значению и удалить предыдущий узел'''
        if self._head is None or self._head.next is None:
            return None
            
        if self._head.next.data == target_value:
            return self.remove_first_node()
            
        current_node = self._head
        while current_node.next is not None and current_node.next.next is not None:
            if current_node.next.next.data == target_value:
                temp = current_node.next.data
                current_node.next = current_node.next.next
                self._size -= 1
                return temp
            current_node = current_node.next
            
        return None




def test_linked_lists():
    """Компактное тестирование связных списков"""
    
    print("ТЕСТИРОВАНИЕ СВЯЗНЫХ СПИСКОВ")
    print("=" * 40)
    
    # Тестируем основные версии
    versions = [SingleLinkedList_v1, SingleLinkedList_v3, SingleLinkedList_v5]
    
    for version_class in versions:
        print(f"\nТестируем {version_class.__name__}:")
        print("-" * 30)
        
        # Создаем список
        lst = version_class()
        
        # 1. Базовые операции
        print("1. Базовые операции:")
        lst.insert_first_node(3)
        lst.insert_first_node(2)
        lst.insert_first_node(1)
        print(f"   После добавления в начало: {lst}")
        
        lst.insert_last_node(4)
        lst.insert_last_node(5)
        print(f"   После добавления в конец: {lst}")
        
        removed_first = lst.remove_first_node()
        print(f"   Удален из начала: {removed_first}")
        
        removed_last = lst.remove_last_node()
        print(f"   Удален из конца: {removed_last}")
        print(f"   Текущий список: {lst}")
        
        # 2. Дополнительные возможности
        if hasattr(lst, 'get_size'):
            print(f"   Размер списка: {lst.get_size()}")
        
        if hasattr(lst, 'find_node'):
            found = lst.find_node(3)
            print(f"   Поиск значения 3: {found}")
        
        if hasattr(lst, 'get_tail'):
            tail = lst.get_tail()
            print(f"   Значение хвоста: {tail}")
        
        print("   [ПРОЙДЕНО]")

def test_edge_cases():
    """Тестирование граничных случаев"""
    print("\nТЕСТИРОВАНИЕ ГРАНИЧНЫХ СЛУЧАЕВ")
    print("=" * 40)
    
    lst = SingleLinkedList_v3()
    
    # 1. Пустой список
    print("1. Пустой список:")
    print(f"   {lst}")
    
    # 2. Удаление из пустого списка
    print("2. Удаление из пустого списка:")
    try:
        lst.remove_first_node()
    except Exception as e:
        print(f"   Ошибка: {type(e).__name__}")
    
    # 3. Один элемент
    print("3. Работа с одним элементом:")
    lst.insert_first_node(999)
    print(f"   Добавлен: {lst}")
    removed = lst.remove_first_node()
    print(f"   Удален: {removed}, список: {lst}")
    
    print("   [ГРАНИЧНЫЕ СЛУЧАИ ПРОЙДЕНЫ]")

def test_advanced_operations():
    """Тестирование продвинутых операций"""
    print("\nТЕСТИРОВАНИЕ ПРОДВИНУТЫХ ОПЕРАЦИЙ")
    print("=" * 40)
    
    # Тестируем v4 с дополнительными функциями
    lst = SingleLinkedList_v4()
    
    # Создаем тестовый список
    for i in range(1, 6):
        lst.insert_last_node(i * 10)
    
    print("1. Исходный список:")
    print(f"   {lst}")
    
    # Тестируем поиск соседей
    print("2. Поиск соседних узлов:")
    prev = lst.find_previous_node(30)
    next_val = lst.find_next_node(30)
    print(f"   Предыдущий для 30: {prev}")
    print(f"   Следующий для 30: {next_val}")
    
    # Тестируем вставку
    print("3. Вставка узлов:")
    lst.insert_before_node(30, 25)
    lst.insert_after_node(30, 35)
    print(f"   После вставки 25 и 35: {lst}")
    
    # Тестируем замену
    print("4. Замена узлов:")
    lst.replace_node(25, 26)
    print(f"   После замены 25 на 26: {lst}")
    
    print("   [ПРОДВИНУТЫЕ ОПЕРАЦИИ ПРОЙДЕНЫ]")

def test_v5_tail_operations():
    """Специфичное тестирование для v5 с хвостом"""
    print("\nТЕСТИРОВАНИЕ V5 (С ХВОСТОМ)")
    print("=" * 40)
    
    lst = SingleLinkedList_v5()
    
    print("1. Проверка хвоста при операциях:")
    lst.insert_last_node(100)
    lst.insert_last_node(200)
    lst.insert_last_node(300)
    print(f"   Список: {lst}")
    print(f"   Хвост: {lst.get_tail()}")
    
    lst.insert_last_node(400)
    print(f"   После добавления 400, хвост: {lst.get_tail()}")
    
    lst.remove_last_node()
    print(f"   После удаления последнего, хвост: {lst.get_tail()}")
    
    print("   [ТЕСТ V5 ПРОЙДЕН]")

def run_all_tests():
    """Запуск всех тестов"""
    print("НАЧАЛО ТЕСТИРОВАНИЯ")
    print("=" * 50)
    
    test_linked_lists()
    test_edge_cases()
    test_advanced_operations()
    test_v5_tail_operations()
    
    print("\n" + "=" * 50)
    print("ВСЕ ТЕСТЫ ЗАВЕРШЕНЫ УСПЕШНО!")

# Запускаем тесты
if __name__ == "__main__":
    run_all_tests()
