---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.3
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```python
import sys
import time
from functools import wraps
from typing import List, Dict, Any
import matplotlib.pyplot as plt
import numpy as np

class AckermannStats:
    def __init__(self):
        self.recursive_calls = 0
        self.max_stack_depth = 0
        self.execution_time = 0
        self.intermediate_results = []
        self.cache_hits = 0
        self.cache_misses = 0
    
    def reset(self):
        self.recursive_calls = 0
        self.max_stack_depth = 0
        self.execution_time = 0
        self.intermediate_results = []
        self.cache_hits = 0
        self.cache_misses = 0

stats = AckermannStats()

# ==================== ЗАДАНИЕ 1: РЕКУРСИВНАЯ РЕАЛИЗАЦИЯ ====================

def ackermann_recursive(x: int, y: int, m: int = None) -> int:
    """
    Рекурсивное вычисление функции Аккермана
    
    Args:
        x: первый аргумент
        y: второй аргумент  
        m: модуль (если None, то вычисляется обычная функция Аккермана)
    
    Returns:
        Значение функции Аккермана A(x, y) mod m
    """
    if x < 0 or y < 0:
        raise ValueError("Аргументы x и y должны быть неотрицательными")
    if m is not None and m <= 0:
        raise ValueError("Модуль m должен быть положительным числом")
    
    # Базовые случаи
    if x == 0:
        result = y + 1
    elif y == 0:
        result = ackermann_recursive(x - 1, 1, m)
    else:
        inner = ackermann_recursive(x, y - 1, m)
        result = ackermann_recursive(x - 1, inner, m)
    
    # Применяем модуль если задан
    if m is not None:
        return result % m
    return result

def ackermann_table_recursive(x_max: int, y_max: int, m: int = None) -> List[List[int]]:
    """
    Построение таблицы значений функции Аккермана рекурсивным методом
    """
    table = []
    for x in range(x_max + 1):
        row = []
        for y in range(y_max + 1):
            row.append(ackermann_recursive(x, y, m))
        table.append(row)
    return table

# ==================== ЗАДАНИЕ 2: ИТЕРАТИВНАЯ РЕАЛИЗАЦИЯ ====================

def ackermann_iterative(x: int, y: int, m: int = None) -> int:
    """
    Нерекурсивная реализация функции Аккермана с использованием стека
    """
    if x < 0 or y < 0:
        raise ValueError("Аргументы x и y должны быть неотрицательными")
    if m is not None and m <= 0:
        raise ValueError("Модуль m должен быть положительным числом")
    
    stack = []
    stack.append(('compute', x, y))
    
    while stack:
        operation, *args = stack.pop()
        
        if operation == 'compute':
            current_x, current_y = args
            
            if current_x == 0:
                result = current_y + 1
                if m is not None:
                    result %= m
                stack.append(('result', result))
                
            elif current_y == 0:
                stack.append(('compute', current_x - 1, 1))
                
            else:
                stack.append(('compute', current_x - 1, None))  # None - placeholder
                stack.append(('compute', current_x, current_y - 1))
                
        elif operation == 'result':
            result = args[0]
            
            # Если на вершине стека операция, ожидающая результат
            if stack and stack[-1][0] == 'compute':
                op, x_val, y_val = stack.pop()
                if y_val is None:  # Это был placeholder
                    stack.append(('compute', x_val, result))
                else:
                    # Должен быть только один результат
                    stack.append(('result', result))
            else:
                # Возвращаем финальный результат
                return result
    
    return 0

# ==================== ЗАДАНИЕ 3: ДОПОЛНИТЕЛЬНЫЙ АНАЛИЗ ====================

# Декоратор для сохранения промежуточных результатов рекурсии
def save_ackermann_intermediate(func):
    @wraps(func)
    def wrapper(x, y, m=None, depth=0):
        stats.recursive_calls += 1
        stats.max_stack_depth = max(stats.max_stack_depth, depth)
        
        intermediate = {
            'depth': depth,
            'x': x,
            'y': y,
            'm': m,
            'timestamp': time.time()
        }
        
        result = func(x, y, m, depth)
        
        intermediate['result'] = result
        stats.intermediate_results.append(intermediate)
        
        return result
    return wrapper

# Рекурсивная реализация с ручным сохранением промежуточных результатов
def manual_ackermann_recursive_with_storage(x: int, y: int, m: int = None) -> int:
    """
    Рекурсивная функция Аккермана с ручным сохранением промежуточных результатов
    """
    intermediate_results = []
    stack_depth = 0
    
    def recursive_helper(x_val, y_val, m_val, depth):
        nonlocal stack_depth
        stack_depth = max(stack_depth, depth)
        stats.recursive_calls += 1
        
        intermediate_results.append({
            'depth': depth,
            'x': x_val,
            'y': y_val,
            'm': m_val,
            'action': 'before_calculation'
        })
        
        if x_val < 0 or y_val < 0:
            raise ValueError("Аргументы x и y должны быть неотрицательными")
        if m_val is not None and m_val <= 0:
            raise ValueError("Модуль m должен быть положительным числом")
        
        if x_val == 0:
            result = y_val + 1
            if m_val is not None:
                result %= m_val
            intermediate_results.append({
                'depth': depth,
                'result': result,
                'action': 'base_case_x_zero'
            })
            return result
        elif y_val == 0:
            intermediate_results.append({
                'depth': depth,
                'action': 'recursive_call_y_zero'
            })
            recursive_result = recursive_helper(x_val - 1, 1, m_val, depth + 1)
            intermediate_results.append({
                'depth': depth,
                'final_result': recursive_result,
                'action': 'after_recursion_y_zero'
            })
            return recursive_result
        else:
            intermediate_results.append({
                'depth': depth,
                'action': 'first_recursive_call'
            })
            inner = recursive_helper(x_val, y_val - 1, m_val, depth + 1)
            intermediate_results.append({
                'depth': depth,
                'inner_result': inner,
                'action': 'after_first_recursion'
            })
            
            intermediate_results.append({
                'depth': depth,
                'action': 'second_recursive_call'
            })
            final_result = recursive_helper(x_val - 1, inner, m_val, depth + 1)
            intermediate_results.append({
                'depth': depth,
                'final_result': final_result,
                'action': 'after_second_recursion'
            })
            return final_result
    
    result = recursive_helper(x, y, m, 0)
    stats.max_stack_depth = stack_depth
    stats.intermediate_results = intermediate_results
    return result

# Рекурсивный алгоритм с декоратором для сохранения промежуточных результатов
@save_ackermann_intermediate
def ackermann_recursive_decorated(x: int, y: int, m: int = None, depth: int = 0) -> int:
    if x < 0 or y < 0:
        raise ValueError("Аргументы x и y должны быть неотрицательными")
    if m is not None and m <= 0:
        raise ValueError("Модуль m должен быть положительным числом")
    
    if x == 0:
        result = y + 1
    elif y == 0:
        result = ackermann_recursive_decorated(x - 1, 1, m, depth + 1)
    else:
        inner = ackermann_recursive_decorated(x, y - 1, m, depth + 1)
        result = ackermann_recursive_decorated(x - 1, inner, m, depth + 1)
    
    if m is not None:
        result %= m
    return result

# Итеративный алгоритм со сбором статистики
def ackermann_iterative_with_stats(x: int, y: int, m: int = None) -> int:
    """
    Итеративная функция Аккермана со сбором статистики
    """
    stats.reset()
    start_time = time.time()
    
    if x < 0 or y < 0:
        raise ValueError("Аргументы x и y должны быть неотрицательными")
    if m is not None and m <= 0:
        raise ValueError("Модуль m должен быть положительным числом")
    
    stack = []
    stack.append((x, y))
    iteration = 0
    
    while len(stack) > 0:
        iteration += 1
        stats.recursive_calls = iteration
        
        current_x, current_y = stack.pop()
        
        stats.intermediate_results.append({
            'iteration': iteration,
            'stack_size': len(stack),
            'current_x': current_x,
            'current_y': current_y,
            'm': m
        })
        
        if isinstance(current_x, int) and isinstance(current_y, int):
            if current_x == 0:
                result = current_y + 1
                if m is not None:
                    result %= m
                stack.append(result)
            elif current_y == 0:
                stack.append(('marker',))
                stack.append((current_x - 1, 1))
            else:
                stack.append(('marker',))
                stack.append((current_x - 1, None))
                stack.append((current_x, current_y - 1))
        elif current_x[0] == 'marker':
            if len(stack) > 0:
                prev_result = stack.pop()
                if isinstance(prev_result, tuple) and len(prev_result) == 2:
                    new_x, placeholder = prev_result
                    if placeholder is None:
                        if len(stack) > 0:
                            inner_result = stack.pop()
                            stack.append((new_x, inner_result))
        else:
            calc_x, calc_result = current_x, current_y
            if calc_x == 0:
                result = calc_result + 1
                if m is not None:
                    result %= m
                stack.append(result)
            else:
                stack.append(('marker',))
                stack.append((calc_x - 1, calc_result))
    
    stats.execution_time = time.time() - start_time
    return stack[0] if stack else 0

# Реализация с мемоизацией
class MemoizedAckermann:
    def __init__(self, m: int = None):
        self.m = m
        self.cache = {}
        self.call_count = 0
        self.cache_hits = 0
    
    def clear_cache(self):
        self.cache.clear()
        self.call_count = 0
        self.cache_hits = 0
    
    def ackermann(self, x: int, y: int) -> int:
        self.call_count += 1
        
        if (x, y) in self.cache:
            self.cache_hits += 1
            return self.cache[(x, y)]
        
        if x == 0:
            result = y + 1
        elif y == 0:
            result = self.ackermann(x - 1, 1)
        else:
            inner = self.ackermann(x, y - 1)
            result = self.ackermann(x - 1, inner)
        
        if self.m is not None:
            result %= self.m
        
        self.cache[(x, y)] = result
        return result

# ==================== АНАЛИЗ И ТЕСТИРОВАНИЕ ====================

def analyze_ackermann_stack_limit():
    """
    Анализ максимальной глубины рекурсии для функции Аккермана
    """
    original_limit = sys.getrecursionlimit()
    print(f"Текущий лимит рекурсии: {original_limit}")
    
    max_safe_x = 0
    max_safe_y = 0
    
    # Тестируем различные комбинации x и y
    test_values = [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), 
                   (3, 6), (3, 7), (3, 8), (3, 9), (3, 10),
                   (4, 0), (4, 1)]
    
    for x, y in test_values:
        try:
            stats.reset()
            result = ackermann_recursive_decorated(x, y)
            max_safe_x = max(max_safe_x, x)
            max_safe_y = max(max_safe_y, y)
            print(f"A({x}, {y}) = {result} - успешно (глубина: {stats.max_stack_depth})")
        except RecursionError:
            print(f"A({x}, {y}) - переполнение стека")
            break
        except Exception as e:
            print(f"A({x}, {y}) - ошибка: {e}")
            break
    
    return max_safe_x, max_safe_y, original_limit

def ackermann_performance_comparison(test_cases):
    """
    Сравнение производительности различных реализаций функции Аккермана
    """
    results = []
    
    for x, y, m in test_cases:
        print(f"\nТестирование A({x}, {y}) с m={m}:")
        
        # Рекурсивный с декоратором
        stats.reset()
        start_time = time.time()
        try:
            result1 = ackermann_recursive_decorated(x, y, m)
            recursive_time = time.time() - start_time
            print(f"Рекурсивный (с декоратором): {result1}")
            print(f"  Время: {recursive_time:.6f}с, Вызовы: {stats.recursive_calls}, Глубина: {stats.max_stack_depth}")
        except Exception as e:
            print(f"Рекурсивный (с декоратором): Ошибка - {e}")
            recursive_time = float('inf')
            result1 = None
        
        # Рекурсивный с ручным сохранением
        stats.reset()
        start_time = time.time()
        try:
            result2 = manual_ackermann_recursive_with_storage(x, y, m)
            manual_recursive_time = time.time() - start_time
            print(f"Рекурсивный (ручное сохранение): {result2}")
            print(f"  Время: {manual_recursive_time:.6f}с, Вызовы: {stats.recursive_calls}, Глубина: {stats.max_stack_depth}")
        except Exception as e:
            print(f"Рекурсивный (ручное сохранение): Ошибка - {e}")
            manual_recursive_time = float('inf')
            result2 = None
        
        # Итеративный
        stats.reset()
        try:
            result3 = ackermann_iterative_with_stats(x, y, m)
            iterative_time = stats.execution_time
            print(f"Итеративный: {result3}")
            print(f"  Время: {iterative_time:.6f}с, Итерации: {stats.recursive_calls}")
        except Exception as e:
            print(f"Итеративный: Ошибка - {e}")
            iterative_time = float('inf')
            result3 = None
        
        # С мемоизацией
        memoizer = MemoizedAckermann(m)
        start_time = time.time()
        try:
            result4 = memoizer.ackermann(x, y)
            memo_time = time.time() - start_time
            print(f"С мемоизацией: {result4}")
            print(f"  Время: {memo_time:.6f}с, Вызовы: {memoizer.call_count}, Попадания в кэш: {memoizer.cache_hits}")
        except Exception as e:
            print(f"С мемоизацией: Ошибка - {e}")
            memo_time = float('inf')
            result4 = None
        
        # Проверка совпадения результатов
        try:
            results_list = [r for r in [result1, result2, result3, result4] if r is not None]
            if all(r == results_list[0] for r in results_list):
                print(" ✓ Все алгоритмы дали одинаковый результат")
            else:
                print(" ✗ Ошибка: результаты различаются")
        except:
            print(" ! Невозможно сравнить результаты из-за ошибок")
        
        results.append({
            'x': x, 'y': y, 'm': m,
            'recursive_time': recursive_time,
            'manual_recursive_time': manual_recursive_time,
            'iterative_time': iterative_time,
            'memo_time': memo_time,
            'recursive_calls': stats.recursive_calls if result1 else 0,
            'stack_depth': stats.max_stack_depth if result1 else 0,
            'memo_calls': memoizer.call_count if result4 else 0,
            'cache_hits': memoizer.cache_hits if result4 else 0
        })
    
    return results

def print_ackermann_intermediate_results():
    """
    Вывод сохраненных промежуточных результатов
    """
    print("\nПромежуточные результаты (последние 10 записей):")
    for i, result in enumerate(stats.intermediate_results[-10:]):
        print(f"  {i+1}: {result}")

def create_ackermann_table_demo():
    """
    Демонстрация создания таблицы значений функции Аккермана
    """
    print("\nДемонстрация таблицы значений A(x, y) для x,y ∈ [0, 3]:")
    print("=" * 50)
    
    try:
        table_rec = ackermann_table_recursive(3, 3)
        print("Рекурсивная реализация:")
        for i, row in enumerate(table_rec):
            print(f"x={i}: {row}")
        
        print("\nИтеративная реализация:")
        table_iter = ackermann_table_iterative(3, 3)
        for i, row in enumerate(table_iter):
            print(f"x={i}: {row}")
            
    except Exception as e:
        print(f"Ошибка при создании таблицы: {e}")

def visualize_ackermann_growth():
    """
    Визуализация роста функции Аккермана
    """
    # Создаем данные для малых значений
    x_values = list(range(0, 4))
    y_values = list(range(0, 6))
    
    data = np.zeros((len(x_values), len(y_values)))
    
    for i, x in enumerate(x_values):
        for j, y in enumerate(y_values):
            try:
                data[i, j] = ackermann_iterative(x, y)
            except Exception:
                data[i, j] = np.nan
    
    # Визуализация
    plt.figure(figsize=(12, 8))
    plt.imshow(data, cmap='plasma', interpolation='nearest')
    plt.colorbar(label='A(x, y)')
    plt.xticks(range(len(y_values)), y_values)
    plt.yticks(range(len(x_values)), x_values)
    plt.xlabel('y')
    plt.ylabel('x')
    plt.title('Функция Аккермана A(x, y)')
    
    # Добавляем значения в ячейки
    for i in range(len(x_values)):
        for j in range(len(y_values)):
            if not np.isnan(data[i, j]):
                plt.text(j, i, f'{int(data[i, j])}', 
                        ha='center', va='center', color='white', fontweight='bold')
    
    plt.tight_layout()
    plt.show()

# ==================== ОСНОВНАЯ ПРОГРАММА ====================

def main():
    print("=" * 70)
    print("АНАЛИЗ АЛГОРИТМОВ ВЫЧИСЛЕНИЯ ФУНКЦИИ АККЕРМАНА")
    print("=" * 70)
    
    print("\n1. АНАЛИЗ ОГРАНИЧЕНИЙ РЕКУРСИИ")
    max_safe_x, max_safe_y, recursion_limit = analyze_ackermann_stack_limit()
    print(f"Максимальные безопасные значения: x={max_safe_x}, y={max_safe_y}")
    
    # Тестовые случаи
    test_cases = [
        (0, 0, None), (0, 5, None), (1, 0, None), (1, 1, None),
        (2, 2, None), (2, 3, None), (3, 1, None), (3, 2, None),
        (2, 2, 5), (3, 1, 10), (1, 3, 3)  # Модульные случаи
    ]
    
    print("\n2. СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ")
    results = ackermann_performance_comparison(test_cases)
    
    print("\n3. СВОДНАЯ СТАТИСТИКА")
    print("Алгоритм           | Среднее время | Вызовы | Глубина | Кэш-попадания")
    print("-" * 75)
    
    # Фильтруем успешные выполнения
    successful_results = [r for r in results if r['recursive_time'] != float('inf')]
    
    if successful_results:
        recursive_times = [r['recursive_time'] for r in successful_results]
        manual_times = [r['manual_recursive_time'] for r in successful_results]
        iterative_times = [r['iterative_time'] for r in successful_results]
        memo_times = [r['memo_time'] for r in successful_results if r['memo_time'] != float('inf')]
        
        avg_recursive = sum(recursive_times) / len(recursive_times) if recursive_times else 0
        avg_manual = sum(manual_times) / len(manual_times) if manual_times else 0
        avg_iterative = sum(iterative_times) / len(iterative_times) if iterative_times else 0
        avg_memo = sum(memo_times) / len(memo_times) if memo_times else 0
        
        max_calls = max(r['recursive_calls'] for r in successful_results)
        max_depth = max(r['stack_depth'] for r in successful_results)
        avg_cache_hits = sum(r['cache_hits'] for r in successful_results if 'cache_hits' in r) / len(successful_results)
        
        print(f"Рекурсивный        | {avg_recursive:.6f}с    | {max_calls:<6} | {max_depth:<7} | -")
        print(f"Ручной рекурсивный | {avg_manual:.6f}с    | {max_calls:<6} | {max_depth:<7} | -")
        print(f"Итеративный        | {avg_iterative:.6f}с    | {max_calls:<6} | -        | -")
        print(f"С мемоизацией      | {avg_memo:.6f}с    | {max_calls:<6} | -        | {avg_cache_hits:.1f}")
    else:
        print("Нет успешных выполнений для сравнения")
    
    print("\n4. ДЕМОНСТРАЦИЯ ТАБЛИЦЫ ЗНАЧЕНИЙ")
    create_ackermann_table_demo()
    
    print("\n5. ДЕМОНСТРАЦИЯ ПРОМЕЖУТОЧНЫХ РЕЗУЛЬТАТОВ")
    stats.reset()
    try:
        ackermann_recursive_decorated(2, 2)
        print_ackermann_intermediate_results()
    except Exception as e:
        print(f"Ошибка при демонстрации: {e}")
    
    print("\n6. ТЕСТИРОВАНИЕ МОДУЛЬНОЙ ФУНКЦИИ АККЕРМАНА")
    print("A(2, 2) mod 5 =", ackermann_iterative(2, 2, 5), "(ожидается: 2)")
    print("A(3, 1) mod 10 =", ackermann_iterative(3, 1, 10), "(ожидается: 3)")
    print("A(1, 3) mod 3 =", ackermann_iterative(1, 3, 3), "(ожидается: 2)")

if __name__ == "__main__":
    main()
    
    # Дополнительная визуализация (раскомментируйте если нужно)
    # print("\n7. ВИЗУАЛИЗАЦИЯ РОСТА ФУНКЦИИ АККЕРМАНА")
    # visualize_ackermann_growth()
```

```python

```
