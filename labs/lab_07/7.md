---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.3
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```python
# ЗАДАНИЕ 1
class Graph:
    def __init__(self):
        self.adj = {}  # словарь списков смежности

    # ---------------- ОПЕРАЦИИ --------------------
    def add_vertex(self, v):
        if v not in self.adj:
            self.adj[v] = []
        else:
            print(f"Вершина {v} уже существует")

    def add_edge(self, v1, v2):
        # создаём вершины если их нет
        if v1 not in self.adj:
            self.add_vertex(v1)
        if v2 not in self.adj:
            self.add_vertex(v2)

        if v2 not in self.adj[v1]:
            self.adj[v1].append(v2)
        if v1 not in self.adj[v2]:
            self.adj[v2].append(v1)

    def remove_vertex(self, v):
        if v in self.adj:
            for key in self.adj:
                if v in self.adj[key]:
                    self.adj[key].remove(v)
            del self.adj[v]
        else:
            print(f"Вершины {v} нет")

    def remove_edge(self, v1, v2):
        if v1 in self.adj and v2 in self.adj[v1]:
            self.adj[v1].remove(v2)
        if v2 in self.adj and v1 in self.adj[v2]:
            self.adj[v2].remove(v1)

    def is_adjacent(self, v1, v2):
        return v1 in self.adj and v2 in self.adj[v1]

    def vertices(self):
        return list(self.adj.keys())

    def edges(self):
        ed = []
        for v in self.adj:
            for u in self.adj[v]:
                if (u, v) not in ed:
                    ed.append((v, u))
        return ed

    # ---------------- АЛГОРИТМЫ --------------------
    def dfs(self, start):
        visited = set()
        order = []

        def dfs_visit(v):
            visited.add(v)
            order.append(v)
            for u in self.adj.get(v, []):
                if u not in visited:
                    dfs_visit(u)

        if start in self.adj:
            dfs_visit(start)
        return order

    def bfs(self, start):
        from collections import deque
        visited = set()
        order = []
        q = deque()

        if start not in self.adj:
            return []

        q.append(start)
        visited.add(start)

        while q:
            v = q.popleft()
            order.append(v)
            for u in self.adj[v]:
                if u not in visited:
                    visited.add(u)
                    q.append(u)

        return order

# ТЕСТ 1 — добавление вершин
g = Graph()
g.add_vertex("A")
g.add_vertex("B")
assert "A" in g.vertices()
assert "B" in g.vertices()
print("ТЕСТ 1 пройден — добавление вершин")

# ТЕСТ 2 — добавление ребра
g = Graph()
g.add_edge("A", "B")
assert g.is_adjacent("A", "B")
assert g.is_adjacent("B", "A")
print("ТЕСТ 2 пройден — добавление ребра")

# ТЕСТ 3 — удаление вершины
g = Graph()
g.add_edge("A", "B")
g.remove_vertex("A")
assert "A" not in g.vertices()
assert not g.is_adjacent("B", "A")
print("ТЕСТ 3 пройден — удаление вершины")

# ТЕСТ 4 — удаление ребра
g = Graph()
g.add_edge("A", "B")
g.remove_edge("A", "B")
assert not g.is_adjacent("A", "B")
print("ТЕСТ 4 пройден — удаление ребра")

# ТЕСТ 5 — вершины и рёбра
g = Graph()
g.add_edge("A", "B")
g.add_edge("A", "C")
assert set(g.vertices()) == {"A", "B", "C"}
assert set(g.edges()) == {("A", "B"), ("A", "C")}
print("ТЕСТ 5 пройден — списки вершин и рёбер")

# ТЕСТ 6 — DFS
g = Graph()
g.add_edge("A", "B")
g.add_edge("A", "C")
g.add_edge("B", "D")

order = g.dfs("A")
assert order in (["A", "B", "D", "C"], ["A", "C", "B", "D"])
print("ТЕСТ 6 пройден — DFS")

# ТЕСТ 7 — BFS
g = Graph()
g.add_edge("A", "B")
g.add_edge("A", "C")
g.add_edge("B", "D")
assert g.bfs("A") == ["A", "B", "C", "D"]
print("ТЕСТ 7 пройден — BFS")

```

```python
##### ЗАДАНИЕ 2
    graph = Graph()
    print("=== Приложение для работы с графом ===")

    while True:
        print("\nМеню:")
        print("1 — Добавить вершину")
        print("2 — Добавить ребро")
        print("3 — Удалить вершину")
        print("4 — Удалить ребро")
        print("5 — Показать вершины")
        print("6 — Показать рёбра")
        print("7 — DFS")
        print("8 — BFS")
        print("0 — Выход")

        choice = input("Ваш выбор: ")

        if choice == "1":
            v = input("Введите вершину: ")
            graph.add_vertex(v)

        elif choice == "2":
            v1 = input("Первая вершина: ")
            v2 = input("Вторая вершина: ")
            graph.add_edge(v1, v2)

        elif choice == "3":
            v = input("Введите вершину: ")
            graph.remove_vertex(v)

        elif choice == "4":
            v1 = input("Первая вершина: ")
            v2 = input("Вторая вершина: ")
            graph.remove_edge(v1, v2)

        elif choice == "5":
            print("Вершины графа:", graph.vertices())

        elif choice == "6":
            print("Рёбра графа:", graph.edges())

        elif choice == "7":
            start = input("Начальная вершина: ")
            print("DFS:", graph.dfs(start))

        elif choice == "8":
            start = input("Начальная вершина: ")
            print("BFS:", graph.bfs(start))

        elif choice == "0":
            print("Выход...")
            break

        else:
            print("Ошибка: неверный пункт меню")

app()

```

```python
# ЗАДАНИЕ 4
import heapq

class DirectedGraph:
    def __init__(self):
        self.adj = {}

    def add_vertex(self, v):
        if v not in self.adj:
            self.adj[v] = []

    def add_edge(self, u, v, w):
        self.add_vertex(u)
        self.add_vertex(v)
        self.adj[u].append((v, w))

    def dijkstra(self, start):
        dist = {v: float('inf') for v in self.adj}
        dist[start] = 0
        prev = {v: None for v in self.adj}
        pq = [(0, start)]

        while pq:
            current_dist, v = heapq.heappop(pq)

            if current_dist > dist[v]:
                continue

            for nei, weight in self.adj[v]:
                new_dist = current_dist + weight
                if new_dist < dist[nei]:
                    dist[nei] = new_dist
                    prev[nei] = v
                    heapq.heappush(pq, (new_dist, nei))

        return dist, prev

    def shortest_path(self, start, end):
        dist, prev = self.dijkstra(start)

        if dist[end] == float('inf'):
            return None, float('inf')

        # восстановление пути
        path = []
        cur = end
        while cur is not None:
            path.append(cur)
            cur = prev[cur]
        path.reverse()

        return path, dist[end]

g = DirectedGraph()

edges = [
    (1, 2, 8),
    (1, 3, 3),
    (2, 5, 5),
    (3, 5, 4),
    (3, 6, 12),
    (2, 4, 1),
    (5, 4, 5),
    (5, 7, 12),
    (5, 6, 4),    
    (6, 7, 7),
    (4, 7, 6),
]


for u, v, w in edges:
    g.add_edge(u, v, w)

print("Граф успешно создан.")

start, end = 2, 6

path, dist = g.shortest_path(start, end)

print("Кратчайший путь от", start, "к", end, ":")
print("Путь:", path)
print("Длина пути:", dist)

```

```python
# ЗАДАНИЕ 5
import heapq

class Graph:
    def __init__(self):
        self.adj = {}

    def add_edge(self, u, v, w):
        self.adj.setdefault(u, []).append((v, w))
        self.adj.setdefault(v, []).append((u, w))  # граф неориентированный

    def dijkstra(self, start):
        dist = {v: float('inf') for v in self.adj}
        dist[start] = 0
        prev = {v: None for v in self.adj}
        pq = [(0, start)]

        while pq:
            curr_dist, v = heapq.heappop(pq)
            if curr_dist > dist[v]:
                continue

            for nei, w in self.adj[v]:
                new_dist = curr_dist + w
                if new_dist < dist[nei]:
                    dist[nei] = new_dist
                    prev[nei] = v
                    heapq.heappush(pq, (new_dist, nei))

        return dist, prev

    def shortest_path(self, start, end):
        dist, prev = self.dijkstra(start)

        if dist[end] == float("inf"):
            return None, float("inf")

        path = []
        cur = end
        while cur is not None:
            path.append(cur)
            cur = prev[cur]
        path.reverse()

        return path, dist[end]

g = Graph()

edges = [
    (1, 2, 6),
    (1, 5, 2),
    (2, 5, 1),
    (2, 6, 5),
    (2, 3, 9),
    (3, 7, 8),
    (3, 7, 3),
    (7, 6, 4),
    (7, 8, 16),
    (3, 4, 12),
    (4, 7, 3),
    (4, 8, 4)
]

for u, v, w in edges:
    g.add_edge(u, v, w)

print("Граф успешно создан.")

start, end = 1, 8

path, dist = g.shortest_path(start, end)

print("Кратчайший путь:", path)
print("Длина пути:", dist)

```

```python
# ЗАДАНИЕ 6
class GraphBF:
    def __init__(self):
        self.edges = []
        self.vertices = set()

    def add_edge(self, u, v, w):
        self.edges.append((u, v, w))
        self.vertices.add(u)
        self.vertices.add(v)

    def bellman_ford(self, start):
        dist = {v: float('inf') for v in self.vertices}
        prev = {v: None for v in self.vertices}

        dist[start] = 0

        # V−1 итераций по рёбрам
        for _ in range(len(self.vertices) - 1):
            for u, v, w in self.edges:
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    prev[v] = u

        # проверка на отрицательные циклы (у нас их нет)
        for u, v, w in self.edges:
            if dist[u] + w < dist[v]:
                raise Exception("Граф содержит отрицательный цикл!")

        return dist, prev

    def shortest_path(self, start, end):
        dist, prev = self.bellman_ford(start)
        if dist[end] == float("inf"):
            return None, float("inf")

        path = []
        cur = end
        while cur is not None:
            path.append(cur)
            cur = prev[cur]
        path.reverse()

        return path, dist[end]

g = GraphBF()

edges = [
    (1, 2, 6),
    (1, 5, 2),
    (2, 5, 1),
    (2, 6, 5),
    (2, 3, 9),
    (3, 7, 8),
    (3, 7, 3),
    (7, 6, 4),
    (7, 8, 16),
    (3, 4, 12),
    (4, 7, 3),
    (4, 8, 4)
]

# добавляем рёбра в обе стороны (неориентированный граф)
for u, v, w in edges:
    g.add_edge(u, v, w)
    g.add_edge(v, u, w)

print("Граф загружен (алгоритм Беллмана–Форда).")

start, end = 1, 8
path, dist = g.shortest_path(start, end)

print("Кратчайший путь:", path)
print("Длина:", dist)

```

```python

```
